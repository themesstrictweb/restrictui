{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sortable",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "clsx",
    "tailwind-merge",
    "@dnd-kit/utilities",
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "registry/default/ui/sortable.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/registry/default/lib/utils';\nimport {\n  DndContext,\n  DragEndEvent,\n  DragOverlay,\n  DragStartEvent,\n  KeyboardSensor,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DraggableSyntheticListeners,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  rectSortingStrategy,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { Slot } from '@radix-ui/react-slot';\n\n// Sortable Item Context\nconst SortableItemContext = React.createContext<{\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n  disabled?: boolean;\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n});\n\n// Multipurpose Sortable Component\nexport interface SortableRootProps<T> {\n  value: T[];\n  onValueChange: (value: T[]) => void;\n  getItemValue: (item: T) => string;\n  children: React.ReactNode;\n  className?: string;\n  onMove?: (event: { event: DragEndEvent; activeIndex: number; overIndex: number }) => void;\n  strategy?: 'horizontal' | 'vertical' | 'grid';\n  onDragStart?: (event: DragStartEvent) => void;\n  onDragEnd?: (event: DragEndEvent) => void;\n}\n\nfunction Sortable<T>({\n  value,\n  onValueChange,\n  getItemValue,\n  children,\n  className,\n  onMove,\n  strategy = 'vertical',\n  onDragStart,\n  onDragEnd,\n}: SortableRootProps<T>) {\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n\n  const handleDragStart = React.useCallback(\n    (event: DragStartEvent) => {\n      setActiveId(event.active.id);\n      onDragStart?.(event);\n    },\n    [onDragStart],\n  );\n\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n      setActiveId(null);\n      onDragEnd?.(event);\n\n      if (!over) return;\n\n      // Handle item reordering\n      const activeIndex = value.findIndex((item: T) => getItemValue(item) === active.id);\n      const overIndex = value.findIndex((item: T) => getItemValue(item) === over.id);\n\n      if (activeIndex !== overIndex) {\n        if (onMove) {\n          onMove({ event, activeIndex, overIndex });\n        } else {\n          const newValue = arrayMove(value, activeIndex, overIndex);\n          onValueChange(newValue);\n        }\n      }\n    },\n    [value, getItemValue, onValueChange, onMove, onDragEnd],\n  );\n\n  const getStrategy = () => {\n    switch (strategy) {\n      case 'horizontal':\n        return rectSortingStrategy;\n      case 'grid':\n        return rectSortingStrategy;\n      case 'vertical':\n      default:\n        return verticalListSortingStrategy;\n    }\n  };\n\n  const itemIds = React.useMemo(() => value.map(getItemValue), [value, getItemValue]);\n\n  return (\n    <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>\n      <SortableContext items={itemIds} strategy={getStrategy()}>\n        <div data-slot=\"sortable\" data-dragging={activeId !== null} className={cn(className)}>\n          {children}\n        </div>\n      </SortableContext>\n\n      <DragOverlay>\n        {activeId ? (\n          <div className=\"z-50\">\n            {React.Children.map(children, (child) => {\n              if (React.isValidElement(child) && (child.props as any).value === activeId) {\n                return React.cloneElement(child as React.ReactElement<any>, {\n                  ...(child.props as any),\n                  className: cn((child.props as any).className, 'z-50 shadow-lg'),\n                });\n              }\n              return null;\n            })}\n          </div>\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}\n\nexport interface SortableItemProps {\n  value: string;\n  asChild?: boolean;\n  className?: string;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nfunction SortableItem({ value, asChild = false, className, children, disabled }: SortableItemProps) {\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n  });\n\n  const style = {\n    transition,\n    transform: CSS.Translate.toString(transform),\n  } as React.CSSProperties;\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <SortableItemContext.Provider value={{ listeners, isDragging: isSortableDragging, disabled }}>\n      <Comp\n        data-slot=\"sortable-item\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        {...attributes}\n        className={cn(isSortableDragging && 'opacity-50 z-50', disabled && 'opacity-50', className)}\n      >\n        {children}\n      </Comp>\n    </SortableItemContext.Provider>\n  );\n}\n\nexport interface SortableItemHandleProps {\n  asChild?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  cursor?: boolean;\n}\n\nfunction SortableItemHandle({ asChild, className, children, cursor = true }: SortableItemHandleProps) {\n  const { listeners, isDragging, disabled } = React.useContext(SortableItemContext);\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      data-slot=\"sortable-item-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...listeners}\n      className={cn(cursor && (isDragging ? '!cursor-grabbing' : '!cursor-grab'), className)}\n    >\n      {children}\n    </Comp>\n  );\n}\n\nexport { Sortable, SortableItem, SortableItemHandle };\n",
      "type": "registry:ui"
    },
    {
      "path": "registry\\default\\ui\\sortable.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/registry/default/lib/utils';\nimport {\n  DndContext,\n  DragEndEvent,\n  DragOverlay,\n  DragStartEvent,\n  KeyboardSensor,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DraggableSyntheticListeners,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  rectSortingStrategy,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { Slot } from '@radix-ui/react-slot';\n\n// Sortable Item Context\nconst SortableItemContext = React.createContext<{\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n  disabled?: boolean;\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n});\n\n// Multipurpose Sortable Component\nexport interface SortableRootProps<T> {\n  value: T[];\n  onValueChange: (value: T[]) => void;\n  getItemValue: (item: T) => string;\n  children: React.ReactNode;\n  className?: string;\n  onMove?: (event: { event: DragEndEvent; activeIndex: number; overIndex: number }) => void;\n  strategy?: 'horizontal' | 'vertical' | 'grid';\n  onDragStart?: (event: DragStartEvent) => void;\n  onDragEnd?: (event: DragEndEvent) => void;\n}\n\nfunction Sortable<T>({\n  value,\n  onValueChange,\n  getItemValue,\n  children,\n  className,\n  onMove,\n  strategy = 'vertical',\n  onDragStart,\n  onDragEnd,\n}: SortableRootProps<T>) {\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n\n  const handleDragStart = React.useCallback(\n    (event: DragStartEvent) => {\n      setActiveId(event.active.id);\n      onDragStart?.(event);\n    },\n    [onDragStart],\n  );\n\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n      setActiveId(null);\n      onDragEnd?.(event);\n\n      if (!over) return;\n\n      // Handle item reordering\n      const activeIndex = value.findIndex((item: T) => getItemValue(item) === active.id);\n      const overIndex = value.findIndex((item: T) => getItemValue(item) === over.id);\n\n      if (activeIndex !== overIndex) {\n        if (onMove) {\n          onMove({ event, activeIndex, overIndex });\n        } else {\n          const newValue = arrayMove(value, activeIndex, overIndex);\n          onValueChange(newValue);\n        }\n      }\n    },\n    [value, getItemValue, onValueChange, onMove, onDragEnd],\n  );\n\n  const getStrategy = () => {\n    switch (strategy) {\n      case 'horizontal':\n        return rectSortingStrategy;\n      case 'grid':\n        return rectSortingStrategy;\n      case 'vertical':\n      default:\n        return verticalListSortingStrategy;\n    }\n  };\n\n  const itemIds = React.useMemo(() => value.map(getItemValue), [value, getItemValue]);\n\n  return (\n    <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>\n      <SortableContext items={itemIds} strategy={getStrategy()}>\n        <div data-slot=\"sortable\" data-dragging={activeId !== null} className={cn(className)}>\n          {children}\n        </div>\n      </SortableContext>\n\n      <DragOverlay>\n        {activeId ? (\n          <div className=\"z-50\">\n            {React.Children.map(children, (child) => {\n              if (React.isValidElement(child) && (child.props as any).value === activeId) {\n                return React.cloneElement(child as React.ReactElement<any>, {\n                  ...(child.props as any),\n                  className: cn((child.props as any).className, 'z-50 shadow-lg'),\n                });\n              }\n              return null;\n            })}\n          </div>\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}\n\nexport interface SortableItemProps {\n  value: string;\n  asChild?: boolean;\n  className?: string;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nfunction SortableItem({ value, asChild = false, className, children, disabled }: SortableItemProps) {\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n  });\n\n  const style = {\n    transition,\n    transform: CSS.Translate.toString(transform),\n  } as React.CSSProperties;\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <SortableItemContext.Provider value={{ listeners, isDragging: isSortableDragging, disabled }}>\n      <Comp\n        data-slot=\"sortable-item\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        {...attributes}\n        className={cn(isSortableDragging && 'opacity-50 z-50', disabled && 'opacity-50', className)}\n      >\n        {children}\n      </Comp>\n    </SortableItemContext.Provider>\n  );\n}\n\nexport interface SortableItemHandleProps {\n  asChild?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  cursor?: boolean;\n}\n\nfunction SortableItemHandle({ asChild, className, children, cursor = true }: SortableItemHandleProps) {\n  const { listeners, isDragging, disabled } = React.useContext(SortableItemContext);\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      data-slot=\"sortable-item-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...listeners}\n      className={cn(cursor && (isDragging ? '!cursor-grabbing' : '!cursor-grab'), className)}\n    >\n      {children}\n    </Comp>\n  );\n}\n\nexport { Sortable, SortableItem, SortableItemHandle };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "registry\\default\\lib\\utils.ts",
      "content": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\n/**\n * Merges Tailwind class names, resolving any conflicts.\n *\n * @param inputs - An array of class names to merge.\n * @returns A string of merged and optimized class names.\n */\nexport function cn(...inputs: ClassValue[]): string {\n  return twMerge(clsx(inputs));\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}