{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scrollspy",
  "dependencies": [],
  "files": [
    {
      "path": "registry/default/ui/scrollspy.tsx",
      "content": "import { ReactNode, RefObject, useCallback, useEffect, useRef } from 'react';\n\ntype ScrollspyProps = {\n  children: ReactNode;\n  targetRef?: RefObject<HTMLElement | HTMLDivElement | Document | null | undefined>;\n  onUpdate?: (id: string) => void;\n  offset?: number;\n  smooth?: boolean;\n  className?: string;\n  dataAttribute?: string;\n  history?: boolean;\n  throttleTime?: number;\n};\n\nexport function Scrollspy({\n  children,\n  targetRef,\n  onUpdate,\n  className,\n  offset = 0,\n  smooth = true,\n  dataAttribute = 'scrollspy',\n  history = true,\n}: ScrollspyProps) {\n  const selfRef = useRef<HTMLDivElement | null>(null);\n  const anchorElementsRef = useRef<Element[] | null>(null);\n  const prevIdTracker = useRef<string | null>(null);\n\n  // Sets active nav, hash, prevIdTracker, and calls onUpdate\n  const setActiveSection = useCallback(\n    (sectionId: string | null, force = false) => {\n      if (!sectionId) return;\n      anchorElementsRef.current?.forEach((item) => {\n        const id = item.getAttribute(`data-${dataAttribute}-anchor`);\n        if (id === sectionId) {\n          item.setAttribute('data-active', 'true');\n        } else {\n          item.removeAttribute('data-active');\n        }\n      });\n      if (onUpdate) onUpdate(sectionId);\n      if (history && (force || prevIdTracker.current !== sectionId)) {\n        window.history.replaceState({}, '', `#${sectionId}`);\n      }\n      prevIdTracker.current = sectionId;\n    },\n    [anchorElementsRef, dataAttribute, history, onUpdate],\n  );\n\n  const handleScroll = useCallback(() => {\n    if (!anchorElementsRef.current || anchorElementsRef.current.length === 0) return;\n    const scrollElement = targetRef?.current === document ? window : targetRef?.current;\n    const scrollTop =\n      scrollElement === window\n        ? window.scrollY || document.documentElement.scrollTop\n        : (scrollElement as HTMLElement).scrollTop;\n\n    // Find the anchor whose section is closest to but not past the top\n    let activeIdx = 0;\n    let minDelta = Infinity;\n    anchorElementsRef.current.forEach((anchor, idx) => {\n      const sectionId = anchor.getAttribute(`data-${dataAttribute}-anchor`);\n      const sectionElement = document.getElementById(sectionId!);\n      if (!sectionElement) return;\n      let customOffset = offset;\n      const dataOffset = anchor.getAttribute(`data-${dataAttribute}-offset`);\n      if (dataOffset) customOffset = parseInt(dataOffset, 10);\n      const delta = Math.abs(sectionElement.offsetTop - customOffset - scrollTop);\n      if (sectionElement.offsetTop - customOffset <= scrollTop && delta < minDelta) {\n        minDelta = delta;\n        activeIdx = idx;\n      }\n    });\n\n    // If at bottom, force last anchor\n    if (scrollElement) {\n      const scrollHeight =\n        scrollElement === window ? document.documentElement.scrollHeight : (scrollElement as HTMLElement).scrollHeight;\n      const clientHeight = scrollElement === window ? window.innerHeight : (scrollElement as HTMLElement).clientHeight;\n      if (scrollTop + clientHeight >= scrollHeight - 2) {\n        activeIdx = anchorElementsRef.current.length - 1;\n      }\n    }\n\n    // Set only one anchor active and sync the URL hash\n    const activeAnchor = anchorElementsRef.current[activeIdx];\n    const sectionId = activeAnchor?.getAttribute(`data-${dataAttribute}-anchor`) || null;\n    setActiveSection(sectionId);\n    // Remove data-active from all others\n    anchorElementsRef.current.forEach((item, idx) => {\n      if (idx !== activeIdx) {\n        item.removeAttribute('data-active');\n      }\n    });\n  }, [anchorElementsRef, targetRef, dataAttribute, offset, setActiveSection]);\n\n  const scrollTo = useCallback(\n    (anchorElement: HTMLElement) => (event?: Event) => {\n      if (event) event.preventDefault();\n      const sectionId = anchorElement.getAttribute(`data-${dataAttribute}-anchor`)?.replace('#', '') || null;\n      if (!sectionId) return;\n      const sectionElement = document.getElementById(sectionId);\n      if (!sectionElement) return;\n\n      const scrollToElement = targetRef?.current === document ? window : targetRef?.current;\n\n      let customOffset = offset;\n      const dataOffset = anchorElement.getAttribute(`data-${dataAttribute}-offset`);\n      if (dataOffset) {\n        customOffset = parseInt(dataOffset, 10);\n      }\n\n      const scrollTop = sectionElement.offsetTop - customOffset;\n\n      if (scrollToElement && 'scrollTo' in scrollToElement) {\n        scrollToElement.scrollTo({\n          top: scrollTop,\n          left: 0,\n          behavior: smooth ? 'smooth' : 'auto',\n        });\n      }\n      setActiveSection(sectionId, true);\n    },\n    [dataAttribute, offset, smooth, targetRef, setActiveSection],\n  );\n\n  // Scroll to the section if the ID is present in the URL hash\n  const scrollToHashSection = useCallback(() => {\n    const hash = CSS.escape(window.location.hash.replace('#', ''));\n\n    if (hash) {\n      const targetElement = document.querySelector(`[data-${dataAttribute}-anchor=\"${hash}\"]`) as HTMLElement;\n      if (targetElement) {\n        scrollTo(targetElement)();\n      }\n    }\n  }, [dataAttribute, scrollTo]);\n\n  useEffect(() => {\n    // Query elements and store them in the ref, avoiding unnecessary re-renders\n    if (selfRef.current) {\n      anchorElementsRef.current = Array.from(selfRef.current.querySelectorAll(`[data-${dataAttribute}-anchor]`));\n    }\n\n    anchorElementsRef.current?.forEach((item) => {\n      item.addEventListener('click', scrollTo(item as HTMLElement));\n    });\n\n    const scrollElement = targetRef?.current === document ? window : targetRef?.current;\n\n    // Attach the scroll event to the correct scrollable element\n    scrollElement?.addEventListener('scroll', handleScroll);\n\n    // Check if there's a hash in the URL and scroll to the corresponding section\n    setTimeout(() => {\n      scrollToHashSection();\n      // Wait for scroll to settle, then update nav highlighting\n      setTimeout(() => {\n        handleScroll();\n      }, 100);\n    }, 100); // Adding a slight delay to ensure content is fully rendered\n\n    return () => {\n      scrollElement?.removeEventListener('scroll', handleScroll);\n      anchorElementsRef.current?.forEach((item) => {\n        item.removeEventListener('click', scrollTo(item as HTMLElement));\n      });\n    };\n  }, [targetRef, selfRef, handleScroll, dataAttribute, scrollTo, scrollToHashSection]);\n\n  return (\n    <div data-slot=\"scrollspy\" className={className} ref={selfRef}>\n      {children}\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry\\default\\ui\\scrollspy.tsx",
      "content": "import { ReactNode, RefObject, useCallback, useEffect, useRef } from 'react';\n\ntype ScrollspyProps = {\n  children: ReactNode;\n  targetRef?: RefObject<HTMLElement | HTMLDivElement | Document | null | undefined>;\n  onUpdate?: (id: string) => void;\n  offset?: number;\n  smooth?: boolean;\n  className?: string;\n  dataAttribute?: string;\n  history?: boolean;\n  throttleTime?: number;\n};\n\nexport function Scrollspy({\n  children,\n  targetRef,\n  onUpdate,\n  className,\n  offset = 0,\n  smooth = true,\n  dataAttribute = 'scrollspy',\n  history = true,\n}: ScrollspyProps) {\n  const selfRef = useRef<HTMLDivElement | null>(null);\n  const anchorElementsRef = useRef<Element[] | null>(null);\n  const prevIdTracker = useRef<string | null>(null);\n\n  // Sets active nav, hash, prevIdTracker, and calls onUpdate\n  const setActiveSection = useCallback(\n    (sectionId: string | null, force = false) => {\n      if (!sectionId) return;\n      anchorElementsRef.current?.forEach((item) => {\n        const id = item.getAttribute(`data-${dataAttribute}-anchor`);\n        if (id === sectionId) {\n          item.setAttribute('data-active', 'true');\n        } else {\n          item.removeAttribute('data-active');\n        }\n      });\n      if (onUpdate) onUpdate(sectionId);\n      if (history && (force || prevIdTracker.current !== sectionId)) {\n        window.history.replaceState({}, '', `#${sectionId}`);\n      }\n      prevIdTracker.current = sectionId;\n    },\n    [anchorElementsRef, dataAttribute, history, onUpdate],\n  );\n\n  const handleScroll = useCallback(() => {\n    if (!anchorElementsRef.current || anchorElementsRef.current.length === 0) return;\n    const scrollElement = targetRef?.current === document ? window : targetRef?.current;\n    const scrollTop =\n      scrollElement === window\n        ? window.scrollY || document.documentElement.scrollTop\n        : (scrollElement as HTMLElement).scrollTop;\n\n    // Find the anchor whose section is closest to but not past the top\n    let activeIdx = 0;\n    let minDelta = Infinity;\n    anchorElementsRef.current.forEach((anchor, idx) => {\n      const sectionId = anchor.getAttribute(`data-${dataAttribute}-anchor`);\n      const sectionElement = document.getElementById(sectionId!);\n      if (!sectionElement) return;\n      let customOffset = offset;\n      const dataOffset = anchor.getAttribute(`data-${dataAttribute}-offset`);\n      if (dataOffset) customOffset = parseInt(dataOffset, 10);\n      const delta = Math.abs(sectionElement.offsetTop - customOffset - scrollTop);\n      if (sectionElement.offsetTop - customOffset <= scrollTop && delta < minDelta) {\n        minDelta = delta;\n        activeIdx = idx;\n      }\n    });\n\n    // If at bottom, force last anchor\n    if (scrollElement) {\n      const scrollHeight =\n        scrollElement === window ? document.documentElement.scrollHeight : (scrollElement as HTMLElement).scrollHeight;\n      const clientHeight = scrollElement === window ? window.innerHeight : (scrollElement as HTMLElement).clientHeight;\n      if (scrollTop + clientHeight >= scrollHeight - 2) {\n        activeIdx = anchorElementsRef.current.length - 1;\n      }\n    }\n\n    // Set only one anchor active and sync the URL hash\n    const activeAnchor = anchorElementsRef.current[activeIdx];\n    const sectionId = activeAnchor?.getAttribute(`data-${dataAttribute}-anchor`) || null;\n    setActiveSection(sectionId);\n    // Remove data-active from all others\n    anchorElementsRef.current.forEach((item, idx) => {\n      if (idx !== activeIdx) {\n        item.removeAttribute('data-active');\n      }\n    });\n  }, [anchorElementsRef, targetRef, dataAttribute, offset, setActiveSection]);\n\n  const scrollTo = useCallback(\n    (anchorElement: HTMLElement) => (event?: Event) => {\n      if (event) event.preventDefault();\n      const sectionId = anchorElement.getAttribute(`data-${dataAttribute}-anchor`)?.replace('#', '') || null;\n      if (!sectionId) return;\n      const sectionElement = document.getElementById(sectionId);\n      if (!sectionElement) return;\n\n      const scrollToElement = targetRef?.current === document ? window : targetRef?.current;\n\n      let customOffset = offset;\n      const dataOffset = anchorElement.getAttribute(`data-${dataAttribute}-offset`);\n      if (dataOffset) {\n        customOffset = parseInt(dataOffset, 10);\n      }\n\n      const scrollTop = sectionElement.offsetTop - customOffset;\n\n      if (scrollToElement && 'scrollTo' in scrollToElement) {\n        scrollToElement.scrollTo({\n          top: scrollTop,\n          left: 0,\n          behavior: smooth ? 'smooth' : 'auto',\n        });\n      }\n      setActiveSection(sectionId, true);\n    },\n    [dataAttribute, offset, smooth, targetRef, setActiveSection],\n  );\n\n  // Scroll to the section if the ID is present in the URL hash\n  const scrollToHashSection = useCallback(() => {\n    const hash = CSS.escape(window.location.hash.replace('#', ''));\n\n    if (hash) {\n      const targetElement = document.querySelector(`[data-${dataAttribute}-anchor=\"${hash}\"]`) as HTMLElement;\n      if (targetElement) {\n        scrollTo(targetElement)();\n      }\n    }\n  }, [dataAttribute, scrollTo]);\n\n  useEffect(() => {\n    // Query elements and store them in the ref, avoiding unnecessary re-renders\n    if (selfRef.current) {\n      anchorElementsRef.current = Array.from(selfRef.current.querySelectorAll(`[data-${dataAttribute}-anchor]`));\n    }\n\n    anchorElementsRef.current?.forEach((item) => {\n      item.addEventListener('click', scrollTo(item as HTMLElement));\n    });\n\n    const scrollElement = targetRef?.current === document ? window : targetRef?.current;\n\n    // Attach the scroll event to the correct scrollable element\n    scrollElement?.addEventListener('scroll', handleScroll);\n\n    // Check if there's a hash in the URL and scroll to the corresponding section\n    setTimeout(() => {\n      scrollToHashSection();\n      // Wait for scroll to settle, then update nav highlighting\n      setTimeout(() => {\n        handleScroll();\n      }, 100);\n    }, 100); // Adding a slight delay to ensure content is fully rendered\n\n    return () => {\n      scrollElement?.removeEventListener('scroll', handleScroll);\n      anchorElementsRef.current?.forEach((item) => {\n        item.removeEventListener('click', scrollTo(item as HTMLElement));\n      });\n    };\n  }, [targetRef, selfRef, handleScroll, dataAttribute, scrollTo, scrollToHashSection]);\n\n  return (\n    <div data-slot=\"scrollspy\" className={className} ref={selfRef}>\n      {children}\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "type": "registry:ui"
}