{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "video-text",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/default/ui/video-text.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { ElementType, ReactNode, useEffect, useRef } from 'react';\nimport { cn } from '@/lib/utils';\n\nexport interface VideoTextProps {\n  /**\n   * The video source URL or array of sources for multiple formats\n   */\n  src: string | string[];\n  /**\n   * The content to display (will have the video \"inside\" it)\n   */\n  children: ReactNode;\n  /**\n   * Additional className for the container\n   */\n  className?: string;\n  /**\n   * Whether to autoplay the video\n   * @default true\n   */\n  autoPlay?: boolean;\n  /**\n   * Whether to mute the video\n   * @default true\n   */\n  muted?: boolean;\n  /**\n   * Whether to loop the video\n   * @default true\n   */\n  loop?: boolean;\n  /**\n   * Whether to preload the video\n   * @default \"auto\"\n   */\n  preload?: 'auto' | 'metadata' | 'none';\n  /**\n   * Font size for the text mask (in viewport width units or CSS units)\n   * @default \"20vw\"\n   */\n  fontSize?: string | number;\n  /**\n   * Font weight for the text mask\n   * @default \"bold\"\n   */\n  fontWeight?: string | number;\n  /**\n   * The element type to render for the container\n   * @default \"div\"\n   */\n  as?: ElementType;\n  /**\n   * Callback when video starts playing\n   */\n  onPlay?: () => void;\n  /**\n   * Callback when video is paused\n   */\n  onPause?: () => void;\n  /**\n   * Callback when video ends\n   */\n  onEnded?: () => void;\n}\n\n/**\n * VideoText displays content with a background video fill effect.\n * The video is masked by the content, creating a dynamic animated text look.\n */\nexport function VideoText({\n  src,\n  children,\n  className = '',\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  preload = 'auto',\n  fontSize = '20vw',\n  fontWeight = 'bold',\n  as: Component = 'div',\n  onPlay,\n  onPause,\n  onEnded,\n}: VideoTextProps) {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const textRef = useRef<HTMLDivElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const textElement = textRef.current;\n    const container = containerRef.current;\n\n    if (!video || !canvas || !textElement || !container) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let animationId: number;\n\n    const updateCanvas = () => {\n      // Get text dimensions first\n      const text = textElement.textContent || '';\n      ctx.font = `${fontWeight} ${typeof fontSize === 'number' ? `${fontSize}px` : fontSize} system-ui, -apple-system, sans-serif`;\n      const textMetrics = ctx.measureText(text);\n      const textWidth = textMetrics.width;\n      const textHeight = typeof fontSize === 'number' ? fontSize : parseFloat(fontSize.replace(/[^\\d.]/g, '')) || 100;\n\n      // Set canvas size to accommodate full text with padding\n      const padding = 40;\n      canvas.width = Math.max(textWidth + padding * 2, 400);\n      canvas.height = Math.max(textHeight + padding * 2, 200);\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw video frame to fill canvas\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // Set up text masking\n      ctx.globalCompositeOperation = 'destination-in';\n\n      // Draw text as mask\n      ctx.fillStyle = 'white';\n      ctx.font = `${fontWeight} ${typeof fontSize === 'number' ? `${fontSize}px` : fontSize} system-ui, -apple-system, sans-serif`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n\n      ctx.fillText(text, canvas.width / 2, canvas.height / 2);\n\n      // Reset composite operation\n      ctx.globalCompositeOperation = 'source-over';\n\n      animationId = requestAnimationFrame(updateCanvas);\n    };\n\n    const handleVideoLoad = () => {\n      updateCanvas();\n    };\n\n    const handleResize = () => {\n      updateCanvas();\n    };\n\n    video.addEventListener('loadeddata', handleVideoLoad);\n    video.addEventListener('play', updateCanvas);\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      video.removeEventListener('loadeddata', handleVideoLoad);\n      video.removeEventListener('play', updateCanvas);\n      window.removeEventListener('resize', handleResize);\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, [fontSize, fontWeight]);\n\n  const sources = Array.isArray(src) ? src : [src];\n  const content = React.Children.toArray(children).join('');\n\n  return (\n    <Component ref={containerRef} className={cn('relative inline-block overflow-hidden', className)}>\n      {/* Hidden video element */}\n      <video\n        ref={videoRef}\n        className=\"absolute opacity-0 pointer-events-none\"\n        autoPlay={autoPlay}\n        muted={muted}\n        loop={loop}\n        preload={preload}\n        playsInline\n        onPlay={onPlay}\n        onPause={onPause}\n        onEnded={onEnded}\n        crossOrigin=\"anonymous\"\n      >\n        {sources.map((source, index) => (\n          <source key={index} src={source} />\n        ))}\n        Your browser does not support the video tag.\n      </video>\n\n      {/* Canvas that shows the masked video */}\n      <canvas\n        ref={canvasRef}\n        className=\"block\"\n        style={{\n          width: '100%',\n          height: 'auto',\n        }}\n      />\n\n      {/* Hidden text for measuring and accessibility */}\n      <div\n        ref={textRef}\n        className=\"absolute opacity-0 pointer-events-none font-bold\"\n        style={{\n          fontSize: typeof fontSize === 'number' ? `${fontSize}px` : fontSize,\n          fontWeight,\n        }}\n        aria-label={content}\n      >\n        {children}\n      </div>\n\n      {/* Screen reader text */}\n      <span className=\"sr-only\">{content}</span>\n    </Component>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry\\default\\ui\\video-text.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { ElementType, ReactNode, useEffect, useRef } from 'react';\nimport { cn } from '@/lib/utils';\n\nexport interface VideoTextProps {\n  /**\n   * The video source URL or array of sources for multiple formats\n   */\n  src: string | string[];\n  /**\n   * The content to display (will have the video \"inside\" it)\n   */\n  children: ReactNode;\n  /**\n   * Additional className for the container\n   */\n  className?: string;\n  /**\n   * Whether to autoplay the video\n   * @default true\n   */\n  autoPlay?: boolean;\n  /**\n   * Whether to mute the video\n   * @default true\n   */\n  muted?: boolean;\n  /**\n   * Whether to loop the video\n   * @default true\n   */\n  loop?: boolean;\n  /**\n   * Whether to preload the video\n   * @default \"auto\"\n   */\n  preload?: 'auto' | 'metadata' | 'none';\n  /**\n   * Font size for the text mask (in viewport width units or CSS units)\n   * @default \"20vw\"\n   */\n  fontSize?: string | number;\n  /**\n   * Font weight for the text mask\n   * @default \"bold\"\n   */\n  fontWeight?: string | number;\n  /**\n   * The element type to render for the container\n   * @default \"div\"\n   */\n  as?: ElementType;\n  /**\n   * Callback when video starts playing\n   */\n  onPlay?: () => void;\n  /**\n   * Callback when video is paused\n   */\n  onPause?: () => void;\n  /**\n   * Callback when video ends\n   */\n  onEnded?: () => void;\n}\n\n/**\n * VideoText displays content with a background video fill effect.\n * The video is masked by the content, creating a dynamic animated text look.\n */\nexport function VideoText({\n  src,\n  children,\n  className = '',\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  preload = 'auto',\n  fontSize = '20vw',\n  fontWeight = 'bold',\n  as: Component = 'div',\n  onPlay,\n  onPause,\n  onEnded,\n}: VideoTextProps) {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const textRef = useRef<HTMLDivElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const textElement = textRef.current;\n    const container = containerRef.current;\n\n    if (!video || !canvas || !textElement || !container) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let animationId: number;\n\n    const updateCanvas = () => {\n      // Get text dimensions first\n      const text = textElement.textContent || '';\n      ctx.font = `${fontWeight} ${typeof fontSize === 'number' ? `${fontSize}px` : fontSize} system-ui, -apple-system, sans-serif`;\n      const textMetrics = ctx.measureText(text);\n      const textWidth = textMetrics.width;\n      const textHeight = typeof fontSize === 'number' ? fontSize : parseFloat(fontSize.replace(/[^\\d.]/g, '')) || 100;\n\n      // Set canvas size to accommodate full text with padding\n      const padding = 40;\n      canvas.width = Math.max(textWidth + padding * 2, 400);\n      canvas.height = Math.max(textHeight + padding * 2, 200);\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw video frame to fill canvas\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // Set up text masking\n      ctx.globalCompositeOperation = 'destination-in';\n\n      // Draw text as mask\n      ctx.fillStyle = 'white';\n      ctx.font = `${fontWeight} ${typeof fontSize === 'number' ? `${fontSize}px` : fontSize} system-ui, -apple-system, sans-serif`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n\n      ctx.fillText(text, canvas.width / 2, canvas.height / 2);\n\n      // Reset composite operation\n      ctx.globalCompositeOperation = 'source-over';\n\n      animationId = requestAnimationFrame(updateCanvas);\n    };\n\n    const handleVideoLoad = () => {\n      updateCanvas();\n    };\n\n    const handleResize = () => {\n      updateCanvas();\n    };\n\n    video.addEventListener('loadeddata', handleVideoLoad);\n    video.addEventListener('play', updateCanvas);\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      video.removeEventListener('loadeddata', handleVideoLoad);\n      video.removeEventListener('play', updateCanvas);\n      window.removeEventListener('resize', handleResize);\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, [fontSize, fontWeight]);\n\n  const sources = Array.isArray(src) ? src : [src];\n  const content = React.Children.toArray(children).join('');\n\n  return (\n    <Component ref={containerRef} className={cn('relative inline-block overflow-hidden', className)}>\n      {/* Hidden video element */}\n      <video\n        ref={videoRef}\n        className=\"absolute opacity-0 pointer-events-none\"\n        autoPlay={autoPlay}\n        muted={muted}\n        loop={loop}\n        preload={preload}\n        playsInline\n        onPlay={onPlay}\n        onPause={onPause}\n        onEnded={onEnded}\n        crossOrigin=\"anonymous\"\n      >\n        {sources.map((source, index) => (\n          <source key={index} src={source} />\n        ))}\n        Your browser does not support the video tag.\n      </video>\n\n      {/* Canvas that shows the masked video */}\n      <canvas\n        ref={canvasRef}\n        className=\"block\"\n        style={{\n          width: '100%',\n          height: 'auto',\n        }}\n      />\n\n      {/* Hidden text for measuring and accessibility */}\n      <div\n        ref={textRef}\n        className=\"absolute opacity-0 pointer-events-none font-bold\"\n        style={{\n          fontSize: typeof fontSize === 'number' ? `${fontSize}px` : fontSize,\n          fontWeight,\n        }}\n        aria-label={content}\n      >\n        {children}\n      </div>\n\n      {/* Screen reader text */}\n      <span className=\"sr-only\">{content}</span>\n    </Component>\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib\\utils.ts",
      "content": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\n/**\n * Merges Tailwind class names, resolving any conflicts.\n *\n * @param inputs - An array of class names to merge.\n * @returns A string of merged and optimized class names.\n */\nexport function cn(...inputs: ClassValue[]): string {\n  return twMerge(clsx(inputs));\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}